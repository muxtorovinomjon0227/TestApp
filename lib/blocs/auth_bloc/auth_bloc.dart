import 'dart:async';import 'package:bloc/bloc.dart';import 'package:equatable/equatable.dart';import 'package:meta/meta.dart';import 'package:test_app/app_models/user_model/user_model.dart';import '../../service/repositorys/auth_repo/user_repo.dart';import '../../src/controllers/stream_controller.dart';part 'auth_event.dart';part 'auth_state.dart';class AuthBloc extends Bloc<AuthEvent, AuthState> {  AuthBloc() : super(AuthInitialState()) {    on<AuthFetchEvent>((event, emit) {      emit(AuthLoadedState());    });    on<AuthLoginEvent>((event, emit) async {      try{        dynamic response = await UserRepository.getInstance().userLogin(emile: event.emile, password: event.password);        event.controller.inputLoadingBool.add(false);        event.controller.inputLoadingBoolAuth.add(false);        if(response["status_code"] == 200){          emit(AuthSuccsessState());        } else if(response["status_code"] > 200 && response["status_code"] < 400) {          emit(AuthDioErrorState(message: response['message']));          emit(AuthLoadedState());        } else {          emit(AuthDioErrorState(message: response['message']));          emit(AuthLoadedState());        }      } catch(e){        emit(AuthExceptionState(message: e.toString()));      }    });    on<AuthPageStateChangeEvent>((event, emit) {      emit(AuthLoadedState(emileIsEmpty: event.emileIsEmpty, passwordIsEmpty: event.passwordIsEmpty));    });  }}